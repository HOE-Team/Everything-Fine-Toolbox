package config

import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.StandardCopyOption

data class AppConfig(val dark: Boolean = false, val color: String? = null)

private val configPath: Path = Path.of("config", "conf.toml")

fun loadConfig(): AppConfig {
    return try {
        if (!Files.exists(configPath)) return AppConfig()
        val lines = Files.readAllLines(configPath)
        var dark: Boolean = false
        var color: String? = null
        for (raw in lines) {
            val line = raw.trim()
            if (line.startsWith("#") || line.isEmpty()) continue
            if (line.startsWith("dark")) {
                val parts = line.split('=', limit = 2)
                if (parts.size == 2) {
                    dark = parts[1].trim().lowercase() == "true"
                }
            } else if (line.startsWith("color")) {
                val parts = line.split('=', limit = 2)
                if (parts.size == 2) {
                    var v = parts[1].trim()
                    if (v.startsWith("\"") && v.endsWith("\"")) v = v.substring(1, v.length - 1)
                    if (v.isNotBlank()) color = v
                }
            }
        }
        AppConfig(dark = dark, color = color)
    } catch (e: Exception) {
        AppConfig()
    }
}

fun saveConfig(cfg: AppConfig) {
    try {
        val dir = configPath.parent
        if (dir != null) Files.createDirectories(dir)
        val tmp = dir.resolve("conf.toml.tmp")
        val sb = StringBuilder()
        sb.append("# Generated by Everything-Fine-Toolbox\n")
        sb.append("dark = ").append(if (cfg.dark) "true" else "false").append('\n')
        sb.append("color = ")
        if (cfg.color != null && cfg.color.isNotBlank()) {
            sb.append('"').append(cfg.color).append('"')
        } else {
            sb.append("\"\"")
        }
        sb.append('\n')
        Files.writeString(tmp, sb.toString())
        Files.move(tmp, configPath, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.ATOMIC_MOVE)
    } catch (e: Exception) {
        // ignore write errors for now
    }
}
